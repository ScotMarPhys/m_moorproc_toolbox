% function [yd,dx,ndx] = ddspike(y,y_tol,stddy_tol,[nloop],[graphics],[dummy],ival)% %  basic despiking of y using two criteria: %       1. values of y beyond the range given in %          y_tol = [y_min y_max] are eliminated %       2. jumps between adjecent values that exceed %          the standard deviation of differences of%          adjecent values (i.e. std(diff(y))) by more%          then stddy_tol times are eliminated        %  spikes are replaced by the value of dummy         %%  input:    y         --- vector to be depiked %            y_tol     --- [dy1 dy2] range of tolerated values %                           accepted values: [median(y)+dy1   median(y)+dy2]%            stddy_tol --- tolerance range of differences%                          between adecent values of y [first guess:15]%            nloop     --- number of loop cycles for the%                          stddy_tol criteria [default 1]%            graphics  --- 'y' displays graphics [default no graphics]%            dummy     --- spike replacement value [default -9999]%            ival      --- 1 = remove only single spikes, 2 = remove twin spikes, . %                           RISCY OPTION, ival = 1 is recommended [default 1]       %  %  output:   yd        --- y with spike replaced by dummy%            dx        --- indices of spikes%            ndx       --- number of spikes %                            % % Kanzow, 7.1.01 (Sonne153)% Kanzow  17.06.02 function [Y,dx,ndx] = ddspike(Y,y_tol,stddy_tol,nloop,graphics,dummy,ival)% ---- input check -----   if nargin < 3       msgbox('not enough input arguments','ddspike.m')   end   if nargin == 3       nloop    = 1;      graphics ='n'      dummy   = -9999;      ival    = 1;    elseif nargin == 4       graphics ='n'      dummy   = -9999;      ival    = 1;   elseif nargin == 5       dummy   = -9999;      ival    = 1;    elseif nargin == 6       ival    = 1;    end   if  nargin >= 6        if isempty(nloop)       nloop=1;     end     if isempty(graphics)        graphics ='n'     end     if isempty(dummy)       dummy = -9999;     end     if isempty(ival)       ival = 1;     end   end% --- check for NaN in input       ynnan    = find(~isnan(Y));   y    = Y(ynnan); % --------------   [m,n] = size(y);   x     = 1:m;   if m == 1      % transpose vector for median calculation       y = y';     x = 1:n;   end    if graphics == 'y'      figure(989)      hold off      plot(y,'k')      hold on         end% ---- cut off values beyond y_tol --------%    my       = medianmiss(y); % SCu JYM Changed to standard matlab CD170 19/4/05    my       = nanmedian(y);        y_co     = find(y <  [my+y_tol(1)] | y >  [my+y_tol(2)]); % cut off range    y_ac     = find(y >= [my+y_tol(1)] & y <= [my+y_tol(2)]); % acc. range     if graphics == 'y'       plot(x(y_co),y(y_co),'ro')    end    y(y_co)  = dummy;% ---- standard deviation loop ------------  y2    =   y(y_ac);    % take one values within y_tols_alt = zeros(length(y2),1);ind   = 1:length(y2);nind  = [];for i = 1 : nloop    ly2    =   length(y2(ind));    dy     =   diff(y2(ind));    %   sdy    =   stdmiss(dy);    % SCU JYM fix to std matlab    sdy    =   nanstd(dy);    disp(['standard deviation =' num2str(sdy)])    dspike    = find(abs(dy)/sdy >=  stddy_tol);       nospike   = find(abs(dy)/sdy <  stddy_tol);    % check if first or last element is a spike    if ~isempty(dspike)          ii        = find(diff(dspike) <= ival); % accept only single spike or twins,                                              % or larger plateaus depending on ival        a1        = [];        a2        = [];         if ~isempty(find(dspike==1)) &  isempty(find(dspike==2))            a1 =1;        end        if isempty(find(dspike==ly2-2)) &  ~isempty(find(dspike==ly2-1))            a2 =ly2;        end                 dspike             = [a1; dspike(ii+1); a2]; % add edges%       dspike             = [a1; [dspike+1]; a2]; % add edges        dspike             = ind(dspike);            % shift index to right place        s_alt(dspike)      = dspike;                 % add index to spike index         ind                = find(s_alt == 0);    else         disp(['no more spikes found after loop cycle ',num2str(nloop)])        break    end          disp(['loop: ',num2str(i),';  spikes: ',num2str(length(find(s_alt~=0)))])    nind   = find(s_alt ~= 0);         if graphics == 'y'       plot(x(y_ac(nind)),y(y_ac(nind)),'go')       drawnow     endend    % std - loop      %-----------------------------------% ----- output ------------%-----------------------------------if ~isempty(nind)  y(y_ac(nind)) = dummy;   dx            = sort([y_co; y_ac(nind)]);else  dx            = y_co;end% keyboardY(ynnan)       = y;               % insert NaNs from input vector%dx   = sort([y_co; y_ac(nind)]); % spike indexndx  = length(dx);                % number of spikes