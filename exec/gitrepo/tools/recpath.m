function  [Msg,pfade,mpath] = recpath(pfad,varargin)% RECPATH   Add's Directory recursivley to Matlab's-SearchPath%% [Msg,Directories,MatlabPath] = RECPATH(Directory,options)%% Msg           contains a ErrorMessage, empty if all ok.% Directories   is the CellstrinArray of the added Directories%% valid options:%%  '-begin'   appends  the directories%  '-end'     prepends the directories%%  '-remove'  removes  the directories%%  '-echo'    display's added Directories in MatlabCommand%%Msg0    = 'RECPATH: ';Msg     = '';pfade   = {};nl      = char(10);tb      = char(32*ones(1,size(Msg0,2)));  % TabSpacefsp     = filesep;psp     = pathsep;comp    = computer;mpath   = matlabpath;Nin = nargin;if Nin < 1 pfad = cd;endif ~( ischar(pfad)  &  ...      ( prod(size(pfad)) == size(pfad,2) ) )  Msg = 'Pfad-Input must be a nonempty String'; returnendVarArgIn = varargin;VarArgIn = VarArgIn(:);if ~iscellstr(VarArgIn) Msg = [ 'Option-Inputs must be strings.' ]; returnend%-------------------------------------is_win = strcmp( upper(comp) , 'PCWIN' );%-------------------------------------% Check Pfadif isempty(pfad) if is_win   pfad = [ 'C:'  fsp ]; else   pfad = fsp; endelseif is_win pfad = strrep(pfad,'/',fsp);  % Take care before UNIX-FileSeperatorend if ~( ( exist(pfad,'dir') == 7 )  |  ...      ( ~is_win  & strcmp(pfad,fsp) ) ) Msg = [ 'Invalid Directory: '  pfad ]; returnendif strcmp(pfad,'.');  pfad = cd;endif strcmp(pfad,'..'); pfad = cd; if isempty(pfad)   pfad = fsp; else   jj = findstr(pfad,fsp);   if ~isempty(jj)     jj(find(jj==size(pfad,2))) = [];   end   if ~isempty(jj)      pfad = pfad(1:max(jj));   end endendif ~isempty(findstr(pfad,'..'))  orgpfad = cd;  ok = 1;  try     cd(pfad);  catch     ok = 0;  end  if ~ok    Msg = ['Invalid Directory:' pfad ];    return  end  pfad = cd;  cd(orgpfad)  if isempty(pfad)    if is_win      pfad = [ 'C:'  fsp ];    else      pfad = fsp;    end  endendpfad = cat( 2 , pfad , fsp(1:(~strcmp(pfad(end),fsp))) );remsep = ~( strcmp(pfad,fsp) | strcmp(comp([1 2]),'MA') );  pfad = pfad( 1 : (end-remsep) );%-------------------------------------% Check OptionsOption = '-end';  mode = 0;if ~isempty(VarArgIn)  jj = find(strcmp(VarArgIn,'-begin') | ...            strcmp(VarArgIn,'-end')   | ...            strcmp(VarArgIn,'-remove')      );  if ~isempty(jj)   Option = VarArgIn{max(jj)};  end  mode = any(strcmp(VarArgIn,'-echo'));end %-------------------------------------%  GetPathif mode  fprintf([ nl Msg0  'Get DirectoryStructure of:' ...            nl nl tb  strrep(pfad,'\','\\') nl ]);end[Msg,pfade] = getpath0([pfad fsp(1:remsep)],remsep,fsp);%-------------------------------------%  SetPathif mode & ~strcmp(Option,'-remove')    str = { 'Append'  'Prepend' };    str = str{ 1 + strcmp(Option,'-begin') };    fprintf([ nl Msg0  str ' Directories to Matlab''s SearchPath:' ...              nl nl tb ...              strrep( strhcat(pfade,'',1,[nl tb]) , '\' , '\\' ) nl ])endmpath = setpath(pfade,psp,Option,is_win);if mode & ~strcmp(Option,'-remove')   fprintf(nl)end%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@qqfunction  mpath = setpath(pfade,psp,Option,is_win);% SETPATH  Set MatlabPath%%  MatlabPath = SETPATH( pfade , PathSep , Option , IsWin );%mpath = matlabpath;  % Current MatlabPath%-------------------------------------------------% Append and Prepend PathSepmpath = cat(  2   , psp(1:(end*(~strcmp(mpath( 1 ),psp)))) , ...            mpath , psp(1:(end*(~strcmp(mpath(end),psp)))) );%-------------------------------------------------% Check for existing Path's in current MatlabPathind = zeros(0,2);  % [ Start  Lenght ] of existing Path'smp = mpath;pf = pfade;if is_win   mp = lower(mp);  % !!!   pf = lower(pf);  % !!!endfor p = pf(:)'    jj = findstr( mp , cat( 2 , psp , p{1} , psp ) );    if ~isempty(jj)       for kk = jj(:)'           ind = cat( 1 , ind , [ kk  size(p{1},2)+1 ] );       end    endend%-------------------------------------------------% Remove Path's from current MatlabPathif ~isempty(ind)   ii = grp2ind(ind(:,1),ind(:,2));   mpath(ii) = [];end%-------------------------------------------------% Append or Prepend Pfadepfade = strhcat( pfade , psp , size(pfade,1)+1 );switch Option  case '-begin'     mpath = cat( 2 , psp , pfade , mpath );      case '-end'     mpath = cat( 2 , mpath , pfade , psp );end%-------------------------------------------------% Remove PathSep from begin and Endmpath = mpath( 2 : ( end-1) );%-------------------------------------------------% Set new MatlabPathmatlabpath( mpath );%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@qqfunction [ Msg , pfade ] = getpath0(pfad,remsep,fsp);% function [ Msg , pfade ] = getpath0(pfad,RemoveSeparator,FileSeperator);Msg     = '';pfade   = {};nl      = char(10);%-------------------------------------%  Recursed = dir(pfad);if isempty(pfad)  returnendis_dir = cat(1,d.isdir);if ~any(is_dir)  returnendis_dir = find(is_dir); pfade    = cell(size(is_dir(:),1),1); pfade(:) = { {} };for ii = 1 : size(pfade,1)  jj = is_dir(ii);  if ~any(strcmp(d(jj).name,{ '.'  '..'  'private' }))  & ...     ~strcmp(d(jj).name(1),'@')    p = cat( 2 , pfad , d(jj).name , fsp(1:(~strcmp(d(jj).name(end),fsp))) );    [msg,pfade{ii}] = getpath0( p , remsep , fsp );    Msg = [ Msg  nl(1:(end*(~isempty(Msg))))  msg ];  endendpfade = cat( 1 , {pfad(1:(end-remsep))} , cat(1,pfade{:}) );%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@function ii = grp2ind(i0,l);% GRP2IND  Built IndexVector from StartIndex and Length%% Index = GRP2IND( StartIndex , GroupLength )%if isempty(i0);   ii = [];   returnendsi = size(i0);if ( sum( si > 1 ) > 1 )   error('StartIndex must be a Vector.');endi0 = i0(:);l  =  l(:);if ~isequal(size(i0,1),size(l,1))   error('Size of StartIndex and GroupLenght must be the same.');endn = size(l,1);ii = ones(sum(l),1);jj = cumsum( cat(1,1,l) , 1 );ii(jj(1:n)) = i0;if n > 1   ii(jj(2:n)) = ii(jj(2:n))-(i0(1:n-1,1)+l(1:n-1)-1);endii = cumsum(ii,1);if n == 1   returnendjj = find( si > 1 );if jj == 1   returnend  perm = cat( 2 , (1:jj-1)+1 , 1 , (jj+1:size(si,2)) );ii = permute(ii,perm);%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@function  str = strhcat(str,del,n,nl)% STRHCAT  Concatenates Strings into ONE%% STRHCAT( StringArray , Delimiter )%   Forms one long String from the Strings in the%   StringArray, delimited with the delimiter.%   The EndDelimiter will be removed.%% STRHCAT( StringArray , Delimiter , N , NewLine )%   Build a  NewLine after each N-th String.%   default: N = 10;  NewLine = char(10);%% Example:  %         >> strhcat({'apples' 'pies' 'prunes'},', ')%    %         ans =%%         apples, pies, prunes%%         >> strhcat({'apples';'pies';'prunes'},', ',2)%    %         ans =%%         apples, pies%         prunes%Nin = nargin;if Nin < 4 nl = char(10);endif Nin < 3 n = 10;endif Nin < 2 del = char((32*ones(1,3)));endif isempty(str) str = ''; returnendif ischar(str)  str = cellstr(str);endstr = str(:);str( : , 2 ) = { del };str(n:n:size(str,1),2) = {nl};str(    size(str,1),2) = { '' };str = permute( str , [ 2  1 ] );str = cat(2,str{:});