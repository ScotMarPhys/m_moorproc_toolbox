% PIES_RAW2USE_OC459 is a script that performs stage2 processing% for PIES data.%% Travel time processing includes:%   a) data is smoothed by calculating hourly medians of each of%      the channels%   b) hourly median from the channel%   c) data is low-pass filtered  %  % Bottom pressure processing includes (via purge_bp.m):%   a) treat pre-launch surface pressure as a constant offset%   b) despike%   c) correct for pressure drift (exponential+linear of linear)%% Two outfiles are saved: the first (e.g. ebp1_1_200564_136.use) contains% travel time and pressure every 1 hour, while the second contains full% temporal resolution pressure data every 10 minutes.%% It calls purge_bp_003.m (with calls exp_lin_fit_2.m), rodbload.m,% rodbsave.m, julian.m, gregorian.m, auto_filt.m% 04.11.08 Szuts: this processing file based on%   seagauge_processing_002.m (for pressure) and ttproc.m (for%   travel time% 27.03.10 Szuts: cleaned up a bit, modified for oc459 (even though%   no RAPID PIES will be recovered/processed during oc459)clear allclose all% -----------------------------------------------------------------% --- This is the information that needs to be modified for -------% --- different users, directory trees, and moorings --------------% -----------------------------------------------------------------% jym 22 April 2005: Request to all operators who change path names % for development purposes -% PLEASE change them back to work on the common computer, so that we do% not have to reinvent the changes over and over again.cruise        = 'd344';operator      = 'zszuts';mooring       = 'ebp2_1_200565';basedir       = '/local/users/pstar/Data/rpdmoc/rapid/data/'; % d344plot_interval = [2005 11 1 0;   % start time of time axis on plot                 2009 11 1 0];  % end time of time axis on plot% -----------------------------------------------------------------% --- set paths for data input and output ---% NB The seagauge dir in outpath must be created firstinpath        = [basedir 'moor/proc/' mooring '/pies/'];outpath       = [basedir 'moor/proc/' mooring '/pies/'];infofile      = [basedir 'moor/proc/' mooring '/' mooring 'info.dat'];clock_file    = [basedir 'moor/raw/' cruise '/pies/bpr_clock_offset.dat'];% ZB Szuts, 27.03.10, oc459% There are 2 clock offset files for BPR instruments:% clock_offset.dat (in raw/oc459/) and BPR_clock_offset.dat in% (raw/oc459/seagauge/):% - clock_offset.dat corrects for constant day/year offsets that% arise from incorrect instrument setup at the beginning of the% record.% - bpr_clock_offset.dat corrects for smaller offsets measured upon% recovery in stage2 processing, and are applied as linear trends% for the whole record.  The sign of the offset is determined by:%   instclock - offset = GMTprogramme     = 'pies_processing_002.m';pies_id       = 316 ; % pies identifier numberdummy         = -9999; % dummy value% --- get mooring information from infofile ---[lat,lon,wd,sdate,stime,edate,etime,z,type,serialnumber] = ...    rodbload(infofile,...             ['Latitude:Longitude:WaterDepth:StartDate:StartTime:'...              'EndDate:EndTime:z:instrument:serialnumber']);% --- find the PIES on the mooring ---pI  = find(type==pies_id);sn  = serialnumber(pI);if length(sn)>1  error(['only one PIES instrument per mooring is expected, not '...         num2str(length(sn))])enddisp(['PIES ',num2str(sn),' has been found'])% --- make input, output, and log files names ---infile    = [inpath mooring '_' sprintf('%3.3d',sn) '.raw'];outfile   = [outpath mooring '_' sprintf('%3.3d',sn) '.use'];outfilep  = [outpath mooring '_' sprintf('%3.3d',sn) '_p.use'];logfile   = [outpath 'stage2_log'];% --- check for existing output or log files ---if exist(outfile,'file')  dooverwrite = ...      input([outfile ' exists already: do you want to overwrite it '...             '(and also ' outfilep ' and ' logfile ', y/n)? '],'s');    if strcmp(dooverwrite,'y')    dirout = dir(outfile);    outfile_old = [outfile '_' datestr(datenum(dirout.date),...                                       'yyyy:mm:dd-HH:MM:SS')];    dirout = dir(outfilep);    outfilep_old = [outfilep '_' datestr(datenum(dirout.date),...                                       'yyyy:mm:dd-HH:MM:SS')];    dirout = dir(logfile);    logfile_old = [logfile '_' datestr(datenum(dirout.date),...                                       'yyyy:mm:dd-HH:MM:SS')];    [succ1,mess1] = copyfile(outfile,outfile_old);    [succ2,mess2] = copyfile(outfilep,outfilep_old);    [succ3,mess3] = copyfile(outlog,outlog_old);  end  end% --- write header info to log file ---fidlog   = fopen(logfile,'w');fprintf(fidlog,['Stage 2 processing of PIES data \n from '...                'mooring %s \n Date: %s \n'],mooring,datestr(clock)');fprintf(fidlog,['Programme: %s\n' programme]);fprintf(fidlog,['Operator: %s\n' operator]);fprintf(fidlog,'Serialnumber %d \n',sn);fprintf(fidlog,'Target Depth [m]: %4.4f\n',instrdepth);fprintf(fidlog,'Infile %s \n',infile);fprintf(fidlog,'Outfile %s \n',outfile);fprintf(fidlog,'Outfile for pressure %s \n',outfilep);% --- load data and carry out basic checks ---[YY,MM,DD,HH,TT1,TT2,TT3,TT4,T,P] = ...    rodbload(infile,'YY:MM:DD:HH:TT1:TT2:TT3:TT4:T:P');jd = julian(YY,MM,DD,HH);% add constant offset to ebp2_1_200565 pressure before 2006/03/11 18:4:58.128% see bp2_1_200565_131.use_withjump.readme for more detailsif strcmp(mooring,'ebp2_1_200565')  ii = find(jd < julian(2006,3,11,18+5/60));  if ~isempty(ii)    P(ii) = P(ii) + diff(P(ii(end)+[0 1]));  end  % 27.03.10 zszuts: I noticed that, during d344, the post-recovery  % clock offset for ebp2_1_200565 (instrument clock is 33 s behind  % GMT) was improperly placed in the file  % rpdmoc/rapid/data/moor/raw/d344/clock_offset.dat, instead of in   % rpdmoc/rapid/data/moor/raw/d344/pies/clock_offset.dat .  For  % further processing, this change should be fixed.  Also, this  % script was changed to assume an opposite sign for the clock  % offset compared with previous versions, so the sign also needs  % to be changed.  (This was done to be consistent with  % seagauge_raw2use_oc459.m  warning(['change post-recovery clock offset from clock_offset.dat ' ...           'to bpr_clock_offset.dat, and change its sign (to -33 s)'])  keyboardend% ---- check for a time offset entry in the 'clock_file' -----time_corr = input(['Correct for clock offset? y/n '],'s');if strcmp(time_corr,'y')  if exist(clock_file,'file')        fid = fopen(clock_file);        cfline = fgetl(fid);    while 1      if strcmp(cfline(1),'%') % throw out comments        cfline = fgetl(fid);      elseif isequal(cfline,-1)        coff = 0; % in seconds        fprintf(1,['Clock offset not found in %s \n'],clock_file);        fprintf(fidlog,['Clock offset not found in %s \n'],clock_file);        coff = input('Enter post deployment clock offset [s] from log sheet ');        break      else        [cf_mooring,cfline] = strtok(cfline);        [cf_inst,cfline] = strtok(cfline);   cf_inst = str2num(cf_inst);        [cf_sn,cfline] = strtok(cfline);    cf_sn = str2num(cf_sn);        if strcmp(mooring,cf_mooring) & sn==cf_sn & cf_inst==pies_id          cf_offsets = str2num(cfline);          coff = sum(cf_offsets.*[86400 3600 60 1]);          break        else          cfline = fgetl(fid)        end      end    end    fclose(fid);  else    fprintf(1,['Clock offset file not found: %s \n'],clock_file);    fprintf(fidlog,['Clock offset not found: %s \n'],clock_file);    coff = input('Enter post deployment clock offset [s] from log sheet ');    end % if exist(clock_file,'file')  % --- calculate a linear clock drift and subtract it from jd ---  len  = length(jd);  coff = linspace(0,coff/86400,len); % assume linear clock drift  jd   = jd - coff';  % subtract drift  fprintf(1,'Clock offset at recovery of %d s (relative to UTC)\n',coff)  fprintf(1,['Calculated a linear trend going through '...             'jd([1 end]) and [0 %s]\n'],coff);  fprintf(1,'and subtracted it from the recorded time')    fprintf(fidlog,'Clock offset at recovery of %d s (relative to UTC)\n',coff)  fprintf(fidlog,['Calculated a linear trend going through '...                  'jd([1 end]) and [0 %s]\n'],coff);  fprintf(fidlog,'and subtracted it from the recorded time')end % if strcmp(time_corr,'y')jd_start = julian([sdate' hms2h([stime;0]')']);jd_end = julian([edate' hms2h([etime;0]')']);sampling_rate = round(1./median(diff(jd))); % nominal sampling rate [per day] % ----------------------------------------------------% ------------- process travel time data -------------% ----------------------------------------------------% based on ttproc.mdisp('processing travel time data - might take some time ...')% cut off frequency for filtering (per day)co   = 1/2;dummy2 = -999; % dummy used in raw dataiibad = find(~isfinite(TT1+TT2+TT3+TT4) & ...             TT1==dummy2 & TT2==dummy2 & ...             TT3==dummy2 & TT4==dummy2 );iigood = setxor(1:length(jd),iibad);TT = [TT1(:) TT2(:) TT3(:) TT4(:)];if length(iigood) > 1  jdtt = jd(iigood,:);   TT = TT(iigood,:);    % force jdtt and TT to have lengths a multiple of 6,   % with times evenly on the hour  hourfrac = rem(jdtt(1)*24,1);  if hourfrac~=0    ii_s = 7 - round(hourfrac*6);    jdtt = jdtt(ii_s:end);    TT = TT(ii_s:end,:);  end    if rem(length(jdtt),6)~=0    ii_e = floor(length(jdtt)/6)*6;    jdtt = jdtt(1:ii_e,:);    TT = TT(1:ii_e,:);  endelse  disp('there is no data recognized as valid - script can''t continue')  fprintf(fidlog,'there is no data recognized as valid - script can''t continue \n')  fclose(fidlog)  returnendif strcmp(mooring,'ebp1_1_200564')  ttlim = [6.7 7];elseif strcmp(mooring,'ebp2_1_200565')  ttlim = [1.32 1.42];else  disp('Set limits on travel time (ttlim) on a per-mooring basis:')  disp(['  not yet set for mooring ' mooring])  fprintf(fidlog,'Set limits on travel time on a per-mooring basis \n')  fprintf(fidlog,['  not yet set for mooring ' mooring])  keyboardend[m,n]     = size(TT);iibad     = find( TT < ttlim(1) | TT > ttlim(2) );TT(iibad) = NaN;% ------------- calculate median single ping hourly values -------------TTm(:,1) = nanmedian(reshape(TT(:,1),m/6,6),2);TTm(:,2) = nanmedian(reshape(TT(:,2),m/6,6),2);TTm(:,3) = nanmedian(reshape(TT(:,3),m/6,6),2);TTm(:,4) = nanmedian(reshape(TT(:,4),m/6,6),2);jdtth     = jdtt(1:6:end); % time every hourttm       = nanmedian(TTm,2); % median of 4 ping hourly mediansiibad      = find(~isfinite(ttm));ttm(iibad) = meannan(ttm);ttmf = auto_filt(ttm,sampling_rate/6,co);% ------------- plot spectra -------------if 1==1 % plot spectra  if 1==0    % these spectra look funny - something's wrong,    % perhaps the mean needs to be removed?    hmtm = spectrum.mtm(3,'Adaptive');    %hmtm = spectrum.mtm(3,'Unity');    Fs = 1/median(diff(jdtth)); % in cycles per day    Ptt = psd(hmtm,ttm,'Fs',Fs);    Pttf = psd(hmtm,ttmf,'Fs',Fs);    [Pttw,freq] = pwelch(ttm,[],[],[],Fs);    [Pttfw,freq] = pwelch(ttmf,[],[],[],Fs);    figure(21)    loglog(Ptt.Frequencies,Ptt.Data,'b-',...        Pttf.Frequencies,Pttf.Data,'r-',...        freq,Pttw,'g-',...        freq,Pttfw,'m-')    xlabel('cycles per day')    ylabel('TT spectral power (s^2 / cpd)')      end    % do spectra by hand  N=length(ttm);  Fs = 1/median(diff(jdtth)); % in cycles per day  ttmavg = sum(ttm)/N;  ttmfavg = sum(ttmf)/N;  ttmstd = sum((ttm-ttmavg).^2)/N; % calculate s0  ttmfstd = sum((ttmf-ttmfavg).^2)/N; % calculate s0  nfft = 2^ceil(log(N)/log(2)); % length of FFT, next power of 2  NW = 4;  K = 2*NW - 1;  % as matlab calculates, for dpss(N,NW), the first 2*NW sequences, input  % NW-1/2 instead  [E,V] = dpss(N,NW-1/2);  % spectra using MultiTaper techniques, with p=95% and unity weight  [Sttm,Sttmerr,F] = pmtm(ttm-ttmavg,E,V,nfft,Fs,'unity',0.95);  [Sttmf,Sttmferr,F] = pmtm(ttmf-ttmfavg,E,V,nfft,Fs,'unity',0.95);  %[ttmstd trapz(F,Sttm)]  %[ttmfstd trapz(F,Sttmf)]  %Bw = [-1 1]*NW/N;  %Var = variancez(2*K,0.95,'10');  %vc=repmat([0.4 1e-1]',2,1);             % variance cross position  % text string to use for titles  titletext = ['Mooring: ' mooring ...               '; PIES s/n: ',num2str(sn),...               '; Target Depth: ',num2str(z) '(m)'];  % ------------- travel time graphics -------------  figure(25), clf  plot(datenum(gregorian(jdtth)),ttm,'k-',datenum(gregorian(jdtth)),ttmf,'r-')  grid on, hold on  datetick('x',12)  ylabel('2-way travel time (s)')  title({titletext,...      'hourly median TT: raw (k), 2-day low-pass filtered (r)'})    print(gcf,'-depsc',[outfile '.tt.eps'])     figure(26), clf  loglog(F,Sttm,'-k',F,Sttmerr(:,1),'-b',F,Sttmerr(:,2),'-b')  grid on, hold on  loglog(F,Sttmf,'-r',F,Sttmferr(:,1),'-m',F,Sttmferr(:,2),'-m')  %semilogy(vc(1,:)+Bw,vc(2,:),'k-',vc(1,:),vc(2,:)*exp(Var),'k-')  xlabel('cycles per day')  ylabel('TT spectral power (s^2 / cpd)')  title({titletext,...      'spectra of hourly median TT: raw (k), 2-day low-pass filtered (r)'})    delete(findobj(gca,'color','b'))  delete(findobj(gca,'color','m'))  print(gcf,'-depsc',[outfile '.tt_spectra.eps'])end% -------------------------------------------------% ------------- process pressure data -------------% -------------------------------------------------% based on seagauge_processing_002.m% --- calculate fits for pressure drifts ---[pr_int,pr_exfit,t_int,jd_grid,pr_linfit,coef_exfit,coef_linfit] =  ...    purge_bp_003(sampling_rate,jd,P,T,[jd_start jd_end],fidlog);% ------------- pressure graphics -------------jd0 = julian(-1,1,1,24);jd1 = julian(plot_interval(1,:))-jd0;jd2 = julian(plot_interval(2,:))-jd0;iip = find(~isnan(pr_int) & pr_int~=dummy);iit = find(~isnan(t_int) & t_int~=dummy);% --- plot original data ---figure(21); clfsubplot(2,1,1);plot(jd_grid(iip)-jd0,pr_int(iip))title(titletext)ylabel('Pressure [dbar]')grid onxlim([jd1 jd2])% timeaxis(plot_interval(1,1:3));datetick('x',12)subplot(2,1,2);plot(jd_grid(iit)-jd0,t_int(iit))ylabel('Temperature [deg C]')grid onxlim([jd1 jd2])% timeaxis(plot_interval(1,1:3));datetick('x',12)orient tallprint(gcf,'-depsc',[outfile '.1.eps'])% --- plot filtered data ---figure(22); clf  % plot 2 day low passsubplot(3,1,1);plot(jd_grid(iip)-jd0,auto_filt(pr_int(iip),sampling_rate,1/2,'low',4))hold onplot(jd_grid-jd0,pr_exfit,'r')plot(jd_grid-jd0,pr_linfit,'g')legend('data','exp.-lin. fit','lin fit')title(titletext)ylabel('Pressure [dbar]')grid onxlim([jd1 jd2])% timeaxis(plot_interval(1,1:3));datetick('x',12)% --- decide whether an exponential+linear or ---% --- linear fit is more apropriate ---disp('Which empirical fit should be stored (see figure 22):')fit_select = input('  (1) exponential-linear  or  (2) linear ? ');if fit_select == 1    fprintf(fidlog,'Exponential-linear pressure fit to be stored with data \n');    fprintf(fidlog,'  amplitude of exponential decay: %f db \n',coef_exfit(1));    fprintf(fidlog,'  time-constant of exponential decay: %f days \n',1/coef_exfit(2));    fprintf(fidlog,'  linear slope: %f db/day \n',coef_exfit(3));    fprintf(fidlog,'  mean offset: %f db \n',coef_exfit(4));    fprintf(1,'Exponential-linear pressure fit stored with data \n');    fprintf(1,'  amplitude of exponential decay: %f db \n',coef_exfit(1));    fprintf(1,'  time-constant of exponential decay: %f days \n',1/coef_exfit(2));    fprintf(1,'  linear slope: %f db/day \n',coef_exfit(3));    fprintf(1,'  mean offset: %f db \n',coef_exfit(4));    pfit = pr_exfit;elseif fit_select == 2    fprintf(fidlog,'Linear pressure fit stored with data \n');    fprintf(fidlog,'  linear slope: %f db/day \n',coef_linfit(1));    fprintf(fidlog,'  mean offset: %f db \n',coef_linfit(2));    fprintf(1,'Linear pressure fit stored with data \n');    fprintf(1,'  linear slope: %f db/day \n',coef_linfit(1));    fprintf(1,'  mean offset: %f db \n',coef_linfit(2));    pfit = pr_linfit;endsubplot(3,1,2);plot(jd_grid(iip)-jd0,auto_filt(pr_int(iip),sampling_rate,1/2,'low',4)-pfit)title('Empirical drift estimate subtracted')ylabel('Pressure [dbar]')grid onxlim([jd1 jd2])% timeaxis(plot_interval(1,1:3));datetick('x',12)subplot(3,1,3);plot(jd_grid(iit)-jd0,auto_filt(t_int(iit),sampling_rate,1/2,'low',4))ylabel('Temperature [deg C]')grid onxlim([jd1 jd2])%  timeaxis(plot_interval(1,1:3));datetick('x',12)orient tallprint(gcf,'-depsc',[outfile '.2.eps']);% ------------- put pressure onto travel time grid -------------if 1==0 % this is quite complicated . . .        % ceil/floor to nearest 10 minutes  jdtth_s = ceil(jdtth(1)*24*6)/24/6;  jd_grid_s = ceil(jd_grid(1)*24*6)/24/6;  jdtth_e = floor(jdtth(end)*24*6)/24/6;  jd_grid_e = floor(jd_grid(end)*24*6)/24/6;  % fractional hour remainder for jd_grid  hrem = rem( round(rem(jd_grid,1)*24*6)/6,1);  if jdtth_s >= jd_grid_s    iip_s = min(find( round(jd_grid*24*6)/24/6 >= jdtth_s -1/86400 & ...                      hrem==0 ));    iitt_s =1;  elseif jdtth_s < jd_grid_s    iip_s = min(find(hrem==0)); % first value on the hour    iitt_s = find( round(jd_grid(iip_s)*24*6) == round(jdtth*24*6) );  end  if jdtth_e >= jd_grid_e    iip_e = max(find(hrem==0));    jd_grid_e = jd_grid(iip_e);    iitt_e = find( round(jd_grid(iip_e)*24*6) == round(jdtth*24*6) );  elseif jdtth_e < jd_grid_e    % last value on the hour less than jdtth_e    iip_e = max(find( hrem==0 & jd_grid <= jdtth_e+1/86400 ));    iitt_e = length(jdtth);    %iitt_e = find( round(jd_grid(iip_e)*24*6) == round(jdtth*24*6) );  endelseif 1==1 % try something simpler - round to the nearest hour  teps = 1e-8; % to make sure exact rounding doesn't get in the way  jdtth_s = ceil((jdtth(1)-teps)*24)/24;  jd_grid_s = ceil((jd_grid(1)-teps)*24)/24;  jd_start = max(jdtth_s,jd_grid_s);  jdtth_e = floor((jdtth(end)+teps)*24)/24;  jd_grid_e = floor((jd_grid(end)+teps)*24)/24;  jd_end = min(jdtth_e,jd_grid_e);  [gash, iip_s] = min(abs(jd_grid - jd_start));  [gash, iitt_s] = min(abs(jdtth - jd_start));  [gash, iip_e] = min(abs(jd_grid - jd_end));  [gash, iitt_e] = min(abs(jdtth - jd_end));endif rem(iip_e - iip_s,6)~=0  disp('iip_s and iip_e are not multiples of 6 apart - something''s wrong')  keyboardendiip = [iip_s:6:iip_e];iitt = [iitt_s:1:iitt_e];if length(iip) ~= length(iitt)   disp('iip and iit are not the same lengths - something''s wrong')    keyboardendjdtth_h = jdtth(iitt);    jdtth_h = jdtth_h(:);jd_grid_h = jd_grid(iip);  jd_grid_h = jd_grid_h(:);isequal( round(jdtth_h*24*6), round(jd_grid_h*24*6) )if ~isequal( round(jdtth_h*24*6), round(jd_grid_h*24*6) )  disp('The aligned time-grids are not the same (within 10 minutes)')  disp('W A R N I N G: rodb output has timing errors')  fprintf(fidlog,['The aligned time-grids are not the same '...      '(within 10 minutes) \n'])  fprintf(fidlog,'W A R N I N G: rodb output has timing errors \n')endttm_h = ttm(iitt);pr_int_h = pr_int(iip);pfit_h = pfit(iip);t_int_h = t_int(iip);% ------------- save data in rodb format -------------% in outfile, save the median of 4-ping hourly medians and the subsampled% pressure data, measurements every hour on the hourcols      = 'YY:MM:DD:HH:TT:P:PFIT:T';fort      = '%4.4d  %2.2d  %2.2d  %7.5f   %8.6f  %8.4f  %8.4f  %7.4f';time       = gregorian(jdtth_h);data      = [time(:,1:3) hms2h(time(:,4:6)) ttm_h(:) ...             pr_int_h(:) pfit_h(:) t_int_h(:)];disp(['writing data to ' outfile]) rodbsave(outfile,...         ['Latitude:Longitude:Columns:Start_Date:Start_Time:'...          'SerialNumber:Mooring:WaterDepth:Instrdepth:End_Date:End_Time'],...         fort,...         lat,lon,cols,sdate,stime(1:2),...         sn,mooring,wd,z,edate,etime(1:2),...         data);% in pressure outfile, save the full time resolution pressure data, % measurements every 10 minutes colsp     = 'YY:MM:DD:HH:P:PFIT:T';fortp     = '%4.4d  %2.2d  %2.2d  %7.5f   %8.4f  %8.4f  %7.4f';timep     = gregorian(jd_grid);datap     = [timep(:,1:3) hms2h(timep(:,4:6)) pr_int(:) pfit(:) t_int(:)];disp(['writing pressure data to ' outfilep])rodbsave(outfilep,...         ['Latitude:Longitude:Columns:Start_Date:Start_Time:'...          'SerialNumber:Mooring:WaterDepth:Instrdepth:End_Date:End_Time'],...         fortp,...         lat,lon,colsp,sdate,stime(1:2),...         sn,mooring,wd,z,edate,etime(1:2),...         datap);     fclose(fidlog);