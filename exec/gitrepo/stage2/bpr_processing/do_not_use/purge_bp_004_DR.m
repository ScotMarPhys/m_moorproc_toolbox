function  [pr_int,pr_tid1,pr_tid2,pr_exfit,t_int,jd_grid,pr_linfit,coef_exfit,coef_linfit] = purge_bp_004(dt,jd,P,T,moor_interval,log,lat,outfile)%  [pr_int,pr_exfit,t_tint,jd_grid,pr_linfit,coef_exfit,coef_linfit] = ...%       purge_bp(dt,jd,P,T,moor_interval,log,lat,outfile)%% this code applies detiding of the data and the fits to a linear% trend and an exponential-linear trend%%  input %    dt  ---- time interval of time series(day) = 1/sampling rate (per day)%    jd  ---- julian day%    P   ---- pressure [dbar]%    T   ---- Temperature [deg C]%    moor_interval --- 2 element vector: start and end time of %                      mooring operation [julian days]  %    lat ---- Latitude (needed for tidal analysis)%    outfile ---- used to generate figure%    t_offset      --- 2 element vector: t_sensor - t_utc prior %                      and after deployment [seconds]%    fid           --- file identy%    [cut_off]     --- Eliminate the first 'cut_off' days from the pressure %                      record, which is commonly exhibits strong drift when %                      the pressure sensor is not equilibrated. If omitted,%                      cut_off = 0 is used%                       %% %  output%  pr_int   ----- despike interpolated data %  pr_tid1   ----- tidal prediction for frequencies higher than semi-monthly%  pr_tid2 -----  monthly and semi-monthly fit/prediction%  pr_exfit ----- exponential - linear fit to pressure data%  t_int    ----- interpolated temperature%  jd_grid  ----- julian day grid%  pr_linfit ---- linear fit to pressure data%  coef_exfit --- the coefficients for the exponential-linear fit%  coef_linfit -- the coefficients for the linear fit%% uses ddspike.m, julian.m, auto_filt.m exp_lin_fit_2.m, t_tide matlab% package routines%% new version including detiding before fit instead of filtering by% Shane Elipot but builds on the code written by% Kanzow, 16.03.05% Z Szuts, 14.11.08% get the mooring nane and instrument id% chnage the%?global cut_off_GLOBALdum = -9999; % dummy values returned possibly by ddspike.m% SKYE: not sure where the global attribute comes fromglobal cut_off_GLOBAL% set to y in order to remove manually extra deployment points; I find that% it is good to do this for BPR data and remove a quarter of tide cyclecut_off_select = 'y';hf=[]; % variable to hold figure handles, for closing at end of script% -- parameters for despiking, % SKYE apparently this could be adjusted but SBE27 seagauge are pretty good % instruments so am not sure if the despiking is useful for this type of instrument pytol        = [-1.8 1.8]; pstddy_tol   = 6; nloop        = 3; % -- parameters for filtering co           = 1/2; % cutoff    [per day]% -- signal to noise ratio limit for applying a detiding at a given% frequencysnr_cutoff = 1;% possible pressure offset to apply  launch     = find(jd < moor_interval(1));  if isempty(launch)   p_offset = 0;   fprintf(log,'purge_bp_004.m: No deployment period apparently\n');   disp('purge_bp_004.m: No deployment period apparently'); else   p_offset   = median(P(launch));   disp(['purge_bp_004.m: Estimated pressure Offset from deployment period: ',num2str(p_offset),' dbar'])   apply = input('Should this offset be removed from the record? (SKYE says: why? launch period will be removed next...): y/n ','s'); end  if strcmp(apply,'y')   P          = P - p_offset;     fprintf(log,'purge_bp_004.m: Pressure offset of %5.2f dbar removed\n', ...                                                           p_offset);   fprintf(1,'purge_bp_004.m: Pressure offset of %5.2f dbar removed\n', ...                                                           p_offset); else   fprintf(log,'purge_bp_004.m: Pressure offset of %5.2f dbar NOT removed\n', ...                                                           p_offset);   fprintf(1,'purge_bp_004.m: Pressure offset of %5.2f dbar NOT removed\n', ...                                                           p_offset); end% ---- cut off launch and recovery periods --- operation = find(jd<=moor_interval(2) & jd>= moor_interval(1)); %  if strcmp(cut_off_select,'y') %      %     hf(end+1) = figure(901); %     hold off%     plot(jd(operation)-jd(operation(1)),P(operation));%     grid on  %     set(gca,'xlim',[-10 jd(operation(end))-jd(operation(1))]);%     title('Deduce from this figure the deployment cutoff:');%     cut_off(1)= input('Select cut off time [in days] at beginning of time series from figure 901: '); %         %     hf(end+1) = figure(902); %     hold off%     plot(jd(operation)-jd(operation(end)),P(operation));%     grid on  %     set(gca,'xlim',[jd(operation(1))-jd(operation(end)) +10]);%     title('Deduce from this figure the recovery cutoff:');%     cut_off(2)= input('Select cut off time [in days, positive] at end of time series from figure 902: '); %  %  end% % %  operation = find(jd<=moor_interval(2)-cut_off(2) & jd>= moor_interval(1)+cut_off(1));   hf(end+1) = figure(901); hold off plot(jd(operation)-jd(operation(1)),P(operation)) grid on   drawnow  if strcmp(cut_off_select,'y')     cut_off_GLOBAL= input('Select cut off time [days] at beginning of time series from figure 901: '); end operation = find(jd<=moor_interval(2) & jd>= moor_interval(1)+cut_off_GLOBAL);   P         = P(operation); T         = T(operation);  jd        = jd(operation); fprintf(log,'purge_bp_004.m: Operation interval: %s  to  %s\n', ...          datestr(gregorian(jd(1))),datestr(gregorian(jd(end)) ));% --- despike ------------------% SKYE: not sure if it is necessary anymore %[Pd,dx,ndx] = ddspike(P,pytol,pstddy_tol,[nloop],'y',dum); %fprintf(log,'purge_bp_004.m: %d spikes removed\n',ndx); Pd = P; % --- interpolate -------------------- valI        = find(Pd ~= dum); jd_grid     = ceil(jd(valI(1))*1440)/1440:dt:floor(jd(valI(length(valI)))*1440)/1440; % time grid (onto which jd is interpolated on) is rounded to integer minutes  % SKYE: not sure why there is an interpolation to rounded minutes here but % why not pr_int      = interp1(jd(valI),Pd(valI),jd_grid); % pressure t_int       = interp1(jd(valI),T(valI),jd_grid);  % temperature  % --- detiding ---  % this uses the detiding from the t_tide Matlab package % I choose a Rayleigh coefficient less than 1 for discriminating the tidal % lines  % the code breaks the time series in 2 in case the time series is longer % than 1 year  %if (jd_grid(end)-jd_grid(1))>365.25 %   %    fprintf(log,'purge_bp_004.m: time series longer than 1 year, tidal analysis may be incorrect\n'); %    fprintf(1,'purge_bp_004.m: time series longer than 1 year, tidal analysis may be incorrect\n'); %                   %end   tlength = jd_grid(end)-jd_grid(1);  if tlength>365.25 & tlength<365.25*2 % time series is between 1 year and 2 years          q1 = find(jd_grid<=jd_grid(1)+365.25);     q2 = find(jd_grid>=jd_grid(end)-365.25);         [tidestruct{1},xout{1}] = t_tide(pr_int(q1),'interval',dt*24,'start time',datenum(gregorian(jd_grid(q1(1)))),...        'latitude',lat,'synthesis',0,'rayleigh',0.25);    [tidestruct{2},xout{2}] = t_tide(pr_int(q2),'interval',dt*24,'start time',datenum(gregorian(jd_grid(q2(1)))),...    'latitude',lat,'synthesis',0,'rayleigh',0.25);    for k = 1:2    %         % need to keep the semi annual, annual, semi-monthly and monthly    %         % frequencies    %         q = find(strcmp('SSA',cellstr(tidestruct{k}.name))|strcmp('SA',cellstr(tidestruct{k}.name))|...    %         strcmp('MSM',cellstr(tidestruct{k}.name))|strcmp('MM',cellstr(tidestruct{k}.name))| ...    %         strcmp('MSF',cellstr(tidestruct{k}.name))|strcmp('MF',cellstr(tidestruct{k}.name)));    %         %         if ~isempty(q)    %             tidestruct{k}.name(q,:) = [];    %             tidestruct{k}.freq(q) = [];    %             tidestruct{k}.tidecon(q,:) = [];    %         end    %      %         % signal to noise ratio of the tidal frequency fits according to t_tide code    %         snr = (tidestruct{k}.tidecon(:,1)./tidestruct{k}.tidecon(:,2)).^2;    %         % choose to remove the tidal constituents with a signal to noise ratio    %         % greater or equal to snr_cutoff; t_tide recommends 1 or 2    %     %         tidestruct{k}.name(snr<snr_cutoff,:) = [];    %         tidestruct{k}.freq(snr<snr_cutoff) = [];    %         tidestruct{k}.tidecon(snr<snr_cutoff,:) = [];    %         %         % keep a record of the tidal constituents fitted; should be added to log    %         % file        % need to keep the semi annual and annual        qa{k} = find(~strcmp('SSA',cellstr(tidestruct{k}.name)) & ~strcmp('SA',cellstr(tidestruct{k}.name)));        qm{k} = find(~strcmp('MSM',cellstr(tidestruct{k}.name)) & ~strcmp('MM',cellstr(tidestruct{k}.name)) & ...            ~strcmp('MSF',cellstr(tidestruct{k}.name)) & ~strcmp('MF',cellstr(tidestruct{k}.name)));        % signal to noise ratio of the tidal frequency fits according to t_tide code        snr = (tidestruct{k}.tidecon(:,1)./tidestruct{k}.tidecon(:,2)).^2;        % choose to remove the tidal constituents with a signal to noise ratio        % greater or equal to snr_cutoff; t_tide recommends 1 or 2        qs{k} = find(snr>snr_cutoff);        % tidal prediction which does not include frequencies lower or equal to than        % semi-monthly        qselect1{k} = intersect(intersect(qa{k},qm{k}),qs{k});        %pr_tid1 = [t_predic(datenum(gregorian(jd_grid)),tidestruct(q),'latitude',lat)]';        % tidal prediction of monthly and semi-monthly tides, even if        % non-significant        qselect2{k} = setdiff(1:length(snr),qm{k});        %pr_tid2 = [t_predic(datenum(gregorian(jd_grid)),tidestruct(q),'latitude',lat)]';            end        % generate the tide prediction for frequencies higher than semi monthly        pr_tid1 = NaN*ones(size(pr_int));    pr_tid11 = pr_tid1;    pr_tid12 = pr_tid1;     tidestructtemp1.name = tidestruct{1}.name(qselect1{1},:);    tidestructtemp1.freq = tidestruct{1}.freq(qselect1{1});    tidestructtemp1.tidecon = tidestruct{1}.tidecon(qselect1{1},:);    tidestructtemp2.name = tidestruct{2}.name(qselect1{2},:);    tidestructtemp2.freq = tidestruct{2}.freq(qselect1{2});    tidestructtemp2.tidecon = tidestruct{2}.tidecon(qselect1{2},:);        pr_tid11(q1) = [t_predic(datenum(gregorian(jd_grid(q1))),tidestructtemp1,'latitude',lat)]';    pr_tid12(q2) = [t_predic(datenum(gregorian(jd_grid(q2))),tidestructtemp2,'latitude',lat)]';        qover = intersect(q1,q2);          pr_tid1(setdiff(q1,qover)) = pr_tid11(setdiff(q1,qover));    pr_tid1(setdiff(q2,qover)) = pr_tid12(setdiff(q2,qover));    % merge overlap period      % create linear weights        w = linspace(0,1,length(qover));    pr_tid1(qover) = (1-w).*pr_tid11(qover) + w.*pr_tid12(qover);           clear tidestructtemp*        % generate the tide prediction for frequencies at semi and monthly    % time scales        pr_tid2 = NaN*ones(size(pr_int));    pr_tid21 = pr_tid2;    pr_tid22 = pr_tid2;            tidestructtemp1.name = tidestruct{1}.name(qselect2{1},:);    tidestructtemp1.freq = tidestruct{1}.freq(qselect2{1},1);    tidestructtemp1.tidecon = tidestruct{1}.tidecon(qselect2{1},:);    tidestructtemp2.name = tidestruct{2}.name(qselect2{2},:);    tidestructtemp2.freq = tidestruct{2}.freq(qselect2{2},1);    tidestructtemp2.tidecon = tidestruct{2}.tidecon(qselect2{2},:);        pr_tid21(q1) = [t_predic(datenum(gregorian(jd_grid(q1))),tidestructtemp1,'latitude',lat)]';    pr_tid22(q2) = [t_predic(datenum(gregorian(jd_grid(q2))),tidestructtemp2,'latitude',lat)]';        qover = intersect(q1,q2);          pr_tid2(setdiff(q1,qover)) = pr_tid21(setdiff(q1,qover));    pr_tid2(setdiff(q2,qover)) = pr_tid22(setdiff(q2,qover));    % merge overlap period      % create linear weights        w = linspace(0,1,length(qover));    pr_tid2(qover) = (1-w).*pr_tid21(qover) + w.*pr_tid22(qover);                elseif tlength<=365.25 % if time series is less than 1 year          [tidestruct,xout] = t_tide(pr_int,'interval',dt*24,'start time',datenum(gregorian(jd_grid(1))),...        'latitude',lat,'synthesis',0,'rayleigh',0.25);        % need to keep the semi annual and annual    qa = find(~strcmp('SSA',cellstr(tidestruct.name)) & ~strcmp('SA',cellstr(tidestruct.name)));            qm = find(~strcmp('MSM',cellstr(tidestruct.name)) & ~strcmp('MM',cellstr(tidestruct.name)) & ...        ~strcmp('MSF',cellstr(tidestruct.name)) & ~strcmp('MF',cellstr(tidestruct.name)));        % signal to noise ratio of the tidal frequency fits according to t_tide code    snr = (tidestruct.tidecon(:,1)./tidestruct.tidecon(:,2)).^2;    % choose to remove the tidal constituents with a signal to noise ratio    % greater or equal to snr_cutoff; t_tide recommends 1 or 2    qs = find(snr>snr_cutoff);        % tidal prediction which does not include frequencies lower than    % semi-monthly        q = intersect(intersect(qa,qm),qs);        tidestructtemp.name = tidestruct.name(q,:);    tidestructtemp.freq = tidestruct.freq(q,1);    tidestructtemp.tidecon = tidestruct.tidecon(q,:);    pr_tid1 = [t_predic(datenum(gregorian(jd_grid)),tidestructtemp,'latitude',lat)]';        clear tidestructtemp        % tidal prediction of monthly and semi-monthly tides, even if    % non-significant        q = setdiff(1:length(snr),qm);        tidestructtemp.name = tidestruct.name(q,:);    tidestructtemp.freq = tidestruct.freq(q,1);    tidestructtemp.tidecon = tidestruct.tidecon(q,:);    pr_tid2 = [t_predic(datenum(gregorian(jd_grid)),tidestructtemp,'latitude',lat)]';         % DR added extra elseif statement to handle record lengths >2 years    elseif tlength>=365.25*2 && tlength<365.25*3 % time series is between 2 years and 3 years          q1 = find(jd_grid<=jd_grid(1)+365.25);     q2 = find((jd_grid>=jd_grid(ceil(length(jd_grid)*2/3))-365.25) & (jd_grid<jd_grid(floor(length(jd_grid)*2/3))));     q3 = find(jd_grid>=jd_grid(end)-365.25);         [tidestruct{1},xout{1}] = t_tide(pr_int(q1),'interval',dt*24,'start time',datenum(gregorian(jd_grid(q1(1)))),...        'latitude',lat,'synthesis',0,'rayleigh',0.25);    [tidestruct{2},xout{2}] = t_tide(pr_int(q2),'interval',dt*24,'start time',datenum(gregorian(jd_grid(q2(1)))),...    'latitude',lat,'synthesis',0,'rayleigh',0.25);    [tidestruct{3},xout{3}] = t_tide(pr_int(q3),'interval',dt*24,'start time',datenum(gregorian(jd_grid(q3(1)))),...    'latitude',lat,'synthesis',0,'rayleigh',0.25);    for k = 1:3        % need to keep the semi annual and annual        qa{k} = find(~strcmp('SSA',cellstr(tidestruct{k}.name)) & ~strcmp('SA',cellstr(tidestruct{k}.name)));        qm{k} = find(~strcmp('MSM',cellstr(tidestruct{k}.name)) & ~strcmp('MM',cellstr(tidestruct{k}.name)) & ...            ~strcmp('MSF',cellstr(tidestruct{k}.name)) & ~strcmp('MF',cellstr(tidestruct{k}.name)));        % signal to noise ratio of the tidal frequency fits according to t_tide code        snr = (tidestruct{k}.tidecon(:,1)./tidestruct{k}.tidecon(:,2)).^2;        % choose to remove the tidal constituents with a signal to noise ratio        % greater or equal to snr_cutoff; t_tide recommends 1 or 2        qs{k} = find(snr>snr_cutoff);        % tidal prediction which does not include frequencies lower or equal to than        % semi-monthly        qselect1{k} = intersect(intersect(qa{k},qm{k}),qs{k});        %pr_tid1 = [t_predic(datenum(gregorian(jd_grid)),tidestruct(q),'latitude',lat)]';        % tidal prediction of monthly and semi-monthly tides, even if        % non-significant        qselect2{k} = setdiff(1:length(snr),qm{k});        %pr_tid2 = [t_predic(datenum(gregorian(jd_grid)),tidestruct(q),'latitude',lat)]';            end        % generate the tide prediction for frequencies higher than semi monthly        pr_tid1 = NaN*ones(size(pr_int));    pr_tid11 = pr_tid1;    pr_tid12 = pr_tid1;    pr_tid13 = pr_tid1;     tidestructtemp1.name = tidestruct{1}.name(qselect1{1},:);    tidestructtemp1.freq = tidestruct{1}.freq(qselect1{1});    tidestructtemp1.tidecon = tidestruct{1}.tidecon(qselect1{1},:);    tidestructtemp2.name = tidestruct{2}.name(qselect1{2},:);    tidestructtemp2.freq = tidestruct{2}.freq(qselect1{2});    tidestructtemp2.tidecon = tidestruct{2}.tidecon(qselect1{2},:);        tidestructtemp3.name = tidestruct{3}.name(qselect1{3},:);    tidestructtemp3.freq = tidestruct{3}.freq(qselect1{3});    tidestructtemp3.tidecon = tidestruct{3}.tidecon(qselect1{3},:);        pr_tid11(q1) = [t_predic(datenum(gregorian(jd_grid(q1))),tidestructtemp1,'latitude',lat)]';    pr_tid12(q2) = [t_predic(datenum(gregorian(jd_grid(q2))),tidestructtemp2,'latitude',lat)]';    pr_tid13(q3) = [t_predic(datenum(gregorian(jd_grid(q3))),tidestructtemp3,'latitude',lat)]';        qover1 = intersect(q1,q2);       qover2 = intersect(q2,q3);       pr_tid1(setdiff(q1,qover1)) = pr_tid11(setdiff(q1,qover1));    pr_tid1(setdiff(q2,qover1)) = pr_tid12(setdiff(q2,qover1));    pr_tid1(setdiff(q2,qover2)) = pr_tid12(setdiff(q2,qover2));    pr_tid1(setdiff(q3,qover2)) = pr_tid13(setdiff(q3,qover2));        % merge overlap period      % create linear weights        w1 = linspace(0,1,length(qover1));    pr_tid1(qover1) = (1-w1).*pr_tid11(qover1) + w1.*pr_tid12(qover1);           w2 = linspace(0,1,length(qover2));    pr_tid1(qover2) = (1-w2).*pr_tid12(qover2) + w2.*pr_tid13(qover2);                   clear tidestructtemp*        % generate the tide prediction for frequencies at semi and monthly    % time scales    pr_tid2 = NaN*ones(size(pr_int));    pr_tid21 = pr_tid2;    pr_tid22 = pr_tid2;    pr_tid23 = pr_tid2;     tidestructtemp1.name = tidestruct{1}.name(qselect2{1},:);    tidestructtemp1.freq = tidestruct{1}.freq(qselect2{1});    tidestructtemp1.tidecon = tidestruct{1}.tidecon(qselect2{1},:);    tidestructtemp2.name = tidestruct{2}.name(qselect2{2},:);    tidestructtemp2.freq = tidestruct{2}.freq(qselect2{2});    tidestructtemp2.tidecon = tidestruct{2}.tidecon(qselect2{2},:);        tidestructtemp3.name = tidestruct{3}.name(qselect2{3},:);    tidestructtemp3.freq = tidestruct{3}.freq(qselect2{3});    tidestructtemp3.tidecon = tidestruct{3}.tidecon(qselect2{3},:);        pr_tid21(q1) = [t_predic(datenum(gregorian(jd_grid(q1))),tidestructtemp1,'latitude',lat)]';    pr_tid22(q2) = [t_predic(datenum(gregorian(jd_grid(q2))),tidestructtemp2,'latitude',lat)]';    pr_tid23(q3) = [t_predic(datenum(gregorian(jd_grid(q3))),tidestructtemp3,'latitude',lat)]';        qover1 = intersect(q1,q2);       qover2 = intersect(q2,q3);       pr_tid2(setdiff(q1,qover1)) = pr_tid21(setdiff(q1,qover1));    pr_tid2(setdiff(q2,qover1)) = pr_tid22(setdiff(q2,qover1));    pr_tid2(setdiff(q2,qover2)) = pr_tid22(setdiff(q2,qover2));    pr_tid2(setdiff(q3,qover2)) = pr_tid23(setdiff(q3,qover2));        % merge overlap period      % create linear weights        w1 = linspace(0,1,length(qover1));    pr_tid2(qover1) = (1-w1).*pr_tid21(qover1) + w1.*pr_tid22(qover1);           w2 = linspace(0,1,length(qover2));    pr_tid2(qover2) = (1-w2).*pr_tid22(qover2) + w2.*pr_tid23(qover2);            else              disp('Sorry, this code cannot deal with time series longer than 3 years, find another dividing of time series for tide analysis');     disp('Or modify the code to add in an exta elseif loop when dividing up the timeseries');          return     end     % --- exponential-linear trend fit to detided record ---try    [exfit_coef,pr_exfit]  = exp_lin_fit2(jd_grid,pr_int-pr_tid1,[1 0.05 0.005 median(pr_int)]);    coef_exfit = exfit_coef;catch    lasterr    pr_exfit = NaN;end% --- linear trend fit to detided record ---linfit_coef            = polyfit(jd_grid-jd_grid(1),pr_int-pr_tid1,1);pr_linfit              = polyval(linfit_coef,jd_grid-jd_grid(1));coef_linfit            = linfit_coef;% --- 2-day lowpass for comparison onlypr_filt     = auto_filt(pr_int,1/dt,co,'low',4);tgood = find(jd_grid>jd_grid(1)+0.5/co & jd_grid<jd_grid(end)-0.5/co);% compute the power spectral density functions for checks% use multitaper estimates which have the best frequency resolution[spd_p,f] = pmtm(detrend(pr_int),4,length(pr_int),1/dt,'adapt');[spd_pdetided,f] = pmtm(detrend(pr_int-pr_tid1),4,length(pr_int),1/dt,'adapt');[spd_pdetided_fit,f] = pmtm(detrend(pr_int-pr_tid1-pr_exfit),4,length(pr_int),1/dt,'adapt');% ----- graphics -------------------------hf(end+1) = figure(501);subplot(2,2,[1 2])hold onset(gca,'xlim',[-10 jd_grid(end)-jd_grid(1)+10]);h1 = plot(jd_grid-jd_grid(1),pr_int,'color',0.5*[1 1 1]);h2 = plot(jd_grid-jd_grid(1),pr_int-pr_tid1,'k');h22 = plot(jd_grid(tgood)-jd_grid(1),pr_filt(tgood),'color',0.5*[0 0 1],'linewidth',1);h3 = plot(jd_grid-jd_grid(1),pr_exfit,'r','linewidth',1);h4 = plot(jd_grid-jd_grid(1),pr_linfit,'color',0.5*[0 1 0],'linewidth',1);ylabel('Pressure (dbar)');xlabel('Days since deployment');box on;legend([h1 h2 h22 h3 h4],{'raw','detided','2-day filtered (not used)','exp-lin fit','linear fit'},'location','southwest');subplot(2,2,[3 4])hold onh1 = plot(f,spd_p,'color',0.5*[1 1 1]);h2 = plot(f,spd_pdetided,'color',0*[0 0 1]);h3 = plot(f,spd_pdetided_fit,'color',1*[1 0 0]);set(gca,'xscale','log','yscale','log');axis tightylabel('PSD (dbar^2/cpd)');xlabel('Frequency (cpd)');box on;legend([h1 h2 h3],{'raw','detided','detided minus exp-lin fit'},'location','southwest');orient tallprint(gcf,'-depsc',[outfile,'.tides.eps']); close(hf)  