% Process travel time and pressure data from PIES%% travel time processing includes:%   a) data is smoothed by calculating hourly medians of each of%     the channels%   b) hourly median from the channel%   c) data is low-pass filtered%% bottom pressure processing includes (via purge_bp.m):%   a) treat pre-launch surface pressure as a constant offset%   b) despike%   c) correct for pressure drift (exponential+linear of linear)%% Two outfiles are saved: the first (e.g. ebp1_1_200564_136.use) contains% travel time and pressure every 1 hour, while the second contains full% temporal resolution pressure data every 10 minutes.%% uses  purge_bp.m, ddspike.m, julian.m, auto_filt.m exp_lin_fit_2.m%% 04/11/08 Szuts: this processing file based on%   seagauge_processing_002.m (for pressure) and ttproc.m (for%   travel time% May 2014 - DR corrected code for applying time drift from% pies_clock_offset.dat file as per JC103 raw data directory.clear allclose all% jym 22 April 2005: Request to all operators who change path names% for development purposes -% PLEASE change them back to work on the common computer, so that we do% not have to reinvent the changes over and over again.%mooring       = 'ebp2_2_201111';cruise        = 'jc103';operator      = 'dr400';programme     = 'pies_processing_002.m';if exist('/Volumes/rpdmoc/rapid/data/exec/jc103/stage1/microcat/mc_call_caldip_jc103_v3.m','file')    % using DR Mac with mount to banba on JC103    basedir = '/Volumes/rpdmoc/rapid/data/';else    basedir = '/local/users/pstar/rpdmoc/rapid/data/';endinpath        = [basedir 'moor/proc/' mooring '/pies/'];outpath       = [basedir 'moor/proc/' mooring '/pies/'];infofile      = [basedir 'moor/proc/' mooring '/' mooring 'info.dat'];clock_file    = [basedir 'moor/raw/' cruise '/pies/pies_clock_offset.dat'];plot_interval = [2011 01 13 0;   % start time of time axis on plot    2014 05 31 0];  % end time of time axis on plotpies_id       = 316 ;         % pies iddummy         = -9999; % dummy value% ------------- load infodat -------------outvars = ['Latitude:Longitude:WaterDepth:StartDate:StartTime:'...    'EndDate:EndTime:z:instrument:serialnumber'];[lat,lon,wd,sdate,stime,edate,etime,z,type,serialnumber] = ...    rodbload(infofile,outvars);pI  = find(type==pies_id);sn  = serialnumber(pI);if length(sn)>1    error(['only one PIES instrument per mooring is expected, not '...        num2str(length(sn))])endlogfile  = [outpath 'stage2_log'];fidlog   = fopen(logfile,'w');fprintf(fidlog,'Stage 2 processing of PIES data \n from mooring %s \n Date: %s \n',...    mooring,datestr(clock)');fprintf(fidlog,['Programme: %s\n' programme]);fprintf(fidlog,['Operator: %s\n' operator]);% ------------- data input file and log file -------------infile    = [inpath mooring '_' sprintf('%3.3d',sn) '.raw'];outfile   = [outpath mooring '_' sprintf('%3.3d',sn) '.use'];outfilep  = [outpath mooring '_' sprintf('%3.3d',sn) '_p.use'];% text string to use for titlestitletext = ['Mooring: ' mooring ...    '; PIES s/n: ',num2str(serialnumber),...    '; Target Depth: ',num2str(z) '(m)'];if exist(infile,'file') ~= 2    disp(['pies rodb file:  ' infile ' does not exist'])    returnendif exist(outfile,'file') == 2    disp(['outfile:  ' outfile ' already exists!!'])    overwrite =  input('Overwrite y/n  ','s');    if overwrite ~='y'        disp('data conversion stop')        return    endendif exist(outfilep,'file') == 2    disp(['pressure outfile:  ' outfilep ' already exists!!'])    overwrite =  input('Overwrite y/n  ','s');    if overwrite ~='y'        disp('data conversion stop')        return    endenddisp(['PIES ',num2str(serialnumber),' has been found'])fprintf(fidlog,'Serialnumber %d \n',serialnumber);fprintf(fidlog,'Infile %s \n',infile);fprintf(fidlog,'Outfile %s \n',outfile);fprintf(fidlog,'Outfile for pressure %s \n',outfilep);[YY,MM,DD,HH,TT1,TT2,TT3,TT4,T,P] = ...    rodbload(infile,'YY:MM:DD:HH:TT1:TT2:TT3:TT4:T:P');jd = julian(YY,MM,DD,HH);% add constant offset to ebp2_1_200565 pressure before 2006/03/11 18:4:58.128% see bp2_1_200565_131.use_withjump.readme for more detailsif strcmp(mooring,'ebp2_1_200565')    ii = find(jd < julian(2006,3,11,18+5/60));    if ~isempty(ii)        P(ii) = P(ii) + diff(P(ii(end)+[0 1]));    endend% ------------- apply clock drift -------------sampling_rate = round(1./median(diff(jd))); % nominal sampling rate [per day]time_corr = input(['Correct for clock offset? y/n '],'s');if strcmp(time_corr,'y')        if exist(clock_file,'file')                fid = fopen(clock_file);                cfline = fgetl(fid);        while 1            if strcmp(cfline(1),'%') % through out comments                cfline = fgetl(fid);            elseif isequal(cfline,-1)                coff = 0; % in seconds                fprintf(1,['Clock offset not found in %s \n'],clock_file);                fprintf(fidlog,['Clock offset not found in %s \n'],clock_file);                coff = input('Enter post deployment clock offset [s] from log sheet ');                break            else                [cf_mooring,cfline] = strtok(cfline);                [cf_inst,cfline] = strtok(cfline);   cf_inst = str2num(cf_inst);                [cf_sn,cfline] = strtok(cfline);    cf_sn = str2num(cf_sn);                if strcmp(mooring,cf_mooring) & serialnumber==cf_sn & cf_inst==pies_id                    cf_offsets = str2num(cfline);                    %coff = sum(cf_offsets.*[86400 3600 60 1]);                    coff = cf_offsets;                    break                else                    cfline = fgetl(fid);                end            end        end        fclose(fid);            else        fprintf(1,['Clock offset file not found: %s \n'],clock_file);        fprintf(fidlog,['Clock offset not found: %s \n'],clock_file);        coff = input('Enter post deployment clock offset [s] from log sheet ');    end        disp(['Applying post recovery clock offset correction of ',...        num2str(coff),' seconds']);    disp('  a linear clock drift over deployment period is assumed');    fprintf(fidlog,'Post recovery clock offset of %d s subtracted \n',coff);    fprintf(fidlog,'  a linear clock drift over deployment period \n');        len  = length(jd);    %coff = linspace(0,coff/86400,len); % assume linear clock drift    coff = linspace(0,coff,len); % assume linear clock drift        jd   = jd + coff';  % adjust to GMT (assuming that instclock + offset = GMT)    endjd_s = julian([sdate' hms2h([stime;0]')']);jd_e = julian([edate' hms2h([etime;0]')']);%disp(['Start is ',num2str(jd_s),', end is ',num2str(jd_e)])% ----------------------------------------------------% ------------- process travel time data -------------% ----------------------------------------------------% based on ttproc.mdisp('processing travel time data - might take some time ...')% cut off frequency for filtering (per day)co   = 1/2;dummy2 = -999; % dummy used in raw dataiibad = find(~isfinite(TT1+TT2+TT3+TT4) & ...    TT1==dummy2 & TT2==dummy2 & ...    TT3==dummy2 & TT4==dummy2 );iigood = setxor(1:length(jd),iibad);TT = [TT1(:) TT2(:) TT3(:) TT4(:)];if length(iigood) > 1    jdtt = jd(iigood,:);    TT = TT(iigood,:);        % force jdtt and TT to have lengths a multiple of 6,    % with times evenly on the hour    hourfrac = rem(jdtt(1)*24,1);    if hourfrac~=0        ii_s = 7 - round(hourfrac*6);        jdtt = jdtt(ii_s:end);        TT = TT(ii_s:end,:);    end        if rem(length(jdtt),6)~=0        ii_e = floor(length(jdtt)/6)*6;        jdtt = jdtt(1:ii_e,:);        TT = TT(1:ii_e,:);    endelse    disp('there is no data recognized as valid - script can''t continue')    fprintf(fidlog,'there is no data recognized as valid - script can''t continue \n')    keyboardendif strcmp(mooring,'ebp1_1_200564')    ttlim = [6.7 7];elseif strcmp(mooring,'ebp2_1_200565')    ttlim = [1.32 1.42];elseif strcmp(mooring,'wbp1_1_201256')    ttlim=[1 546812];elseif strcmp(mooring,'ebp2_2_201111')    ttlim = [1.32 1.42];else    disp('Set limits on travel time (ttlim) on a per-mooring basis:')    disp(['  not yet set for mooring ' mooring])    fprintf(fidlog,'Set limits on travel time on a per-mooring basis \n')    fprintf(fidlog,['  not yet set for mooring ' mooring])    keyboardend[m,n]     = size(TT);iibad     = find( TT < ttlim(1) | TT > ttlim(2) );TT(iibad) = NaN;% ------------- calculate median single ping hourly values -------------TTm(:,1) = nanmedian(reshape(TT(:,1),m/6,6),2);TTm(:,2) = nanmedian(reshape(TT(:,2),m/6,6),2);TTm(:,3) = nanmedian(reshape(TT(:,3),m/6,6),2);TTm(:,4) = nanmedian(reshape(TT(:,4),m/6,6),2);jdtth     = jdtt(1:6:end); % time every hourttm       = nanmedian(TTm,2); % median of 4 ping hourly mediansiibad      = find(~isfinite(ttm));ttm(iibad) = meannan(ttm);ttmf = auto_filt(ttm,sampling_rate/6,co);% ------------- plot spectra -------------if 1==1 % plot spectra    if 1==0        % these spectra look funny - something's wrong,        % perhaps the mean needs to be removed?                hmtm = spectrum.mtm(3,'Adaptive');        %hmtm = spectrum.mtm(3,'Unity');                Fs = 1/median(diff(jdtth)); % in cycles per day                Ptt = psd(hmtm,ttm,'Fs',Fs);        Pttf = psd(hmtm,ttmf,'Fs',Fs);        [Pttw,freq] = pwelch(ttm,[],[],[],Fs);        [Pttfw,freq] = pwelch(ttmf,[],[],[],Fs);                figure(21)        loglog(Ptt.Frequencies,Ptt.Data,'b-',...            Pttf.Frequencies,Pttf.Data,'r-',...            freq,Pttw,'g-',...            freq,Pttfw,'m-')        xlabel('cycles per day')        ylabel('TT spectral power (s^2 / cpd)')            end        % do spectra by hand        N=length(ttm);    Fs = 1/median(diff(jdtth)); % in cycles per day        ttmavg = sum(ttm)/N;    ttmfavg = sum(ttmf)/N;        ttmstd = sum((ttm-ttmavg).^2)/N; % calculate s0    ttmfstd = sum((ttmf-ttmfavg).^2)/N; % calculate s0        nfft = 2^ceil(log(N)/log(2)); % length of FFT, next power of 2    NW = 4;    K = 2*NW - 1;        % as matlab calculates, for dpss(N,NW), the first 2*NW sequences, input    % NW-1/2 instead    [E,V] = dpss(N,NW-1/2);        % spectra using MultiTaper techniques, with p=95% and unity weight    [Sttm,Sttmerr,F] = pmtm(ttm-ttmavg,E,V,nfft,Fs,'unity',0.95);    [Sttmf,Sttmferr,F] = pmtm(ttmf-ttmfavg,E,V,nfft,Fs,'unity',0.95);        %[ttmstd trapz(F,Sttm)]    %[ttmfstd trapz(F,Sttmf)]        %Bw = [-1 1]*NW/N;    %Var = variancez(2*K,0.95,'10');    %vc=repmat([0.4 1e-1]',2,1);             % variance cross position        figure(25), clf    plot(datenum(gregorian(jdtth)),ttm,'k-',datenum(gregorian(jdtth)),ttmf,'r-')    grid on, hold on    datetick('x',12)    ylabel('2-way travel time (s)')    title({titletext,...        'hourly median TT: raw (k), 2-day low-pass filtered (r)'})        print(gcf,'-depsc',[outfile '.tt.eps'])            figure(26), clf    loglog(F,Sttm,'-k',F,Sttmerr(:,1),'-b',F,Sttmerr(:,2),'-b')    grid on, hold on    loglog(F,Sttmf,'-r',F,Sttmferr(:,1),'-m',F,Sttmferr(:,2),'-m')    %semilogy(vc(1,:)+Bw,vc(2,:),'k-',vc(1,:),vc(2,:)*exp(Var),'k-')    xlabel('cycles per day')    ylabel('TT spectral power (s^2 / cpd)')    title({titletext,...        'spectra of hourly median TT: raw (k), 2-day low-pass filtered (r)'})        delete(findobj(gca,'color','b'))    delete(findobj(gca,'color','m'))    print(gcf,'-depsc',[outfile '.tt_spectra.eps'])    end% -------------------------------------------------% ------------- process pressure data -------------% -------------------------------------------------% based on seagauge_processing_002.mhfs = get(0,'children');[pr_int,pr_exfit,t_int,jd_grid,pr_linfit,coef_exfit,coef_linfit] =  ...    purge_bp_003(sampling_rate,jd,P,T,[jd_s jd_e],fidlog);hfe = get(0,'children');close(setxor(hfs,hfe)) % close figures created by purge_bp.m% ------------- pressure graphics -------------jd0 = julian(-1,1,1,24);jd1 = julian(plot_interval(1,:))-jd0;jd2 = julian(plot_interval(2,:))-jd0;iip = find(~isnan(pr_int) & pr_int~=dummy);iit = find(~isnan(t_int) & t_int~=dummy);figure(21); clfsubplot(2,1,1);plot(jd_grid(iip)-jd0,pr_int(iip))title(titletext)ylabel('Pressure [dbar]')grid onxlim([jd1 jd2])% timeaxis(plot_interval(1,1:3));datetick('x',12)subplot(2,1,2);plot(jd_grid(iit)-jd0,t_int(iit))ylabel('Temperature [deg C]')grid onxlim([jd1 jd2])% timeaxis(plot_interval(1,1:3));orient talldatetick('x',12)print(gcf,'-depsc',[outfile '.1.eps'])% 2 day low passfigure(22); clfsubplot(3,1,1);plot(jd_grid(iip)-jd0,auto_filt(pr_int(iip),sampling_rate,1/2,'low',4))hold onplot(jd_grid-jd0,pr_exfit,'r')plot(jd_grid-jd0,pr_linfit,'g')legend('data','exp.-lin. fit','lin fit')title(titletext)ylabel('Pressure [dbar]')grid onxlim([jd1 jd2])% timeaxis(plot_interval(1,1:3));datetick('x',12)% ------------- decide which fit is best -------------disp('Which empirical fit should be stored (see figure 22):')fit_select = input('  (1) exponential-linear  or  (2) linear or (3) none? ');if fit_select == 1    fprintf(1,'Exponential-linear pressure fit stored with data \n');    fprintf(1,'  amplitude of exponential decay: %f db \n',coef_exfit(1));    fprintf(1,'  time-constant of exponential decay: %f days \n',1/coef_exfit(2));    fprintf(1,'  linear slope: %f db/day \n',coef_exfit(3));    fprintf(1,'  mean offset: %f db \n',coef_exfit(4));        fprintf(fidlog,'Exponential-linear pressure fit to be stored with data \n');    fprintf(fidlog,'  amplitude of exponential decay: %f db \n',coef_exfit(1));    fprintf(fidlog,'  time-constant of exponential decay: %f days \n',1/coef_exfit(2));    fprintf(fidlog,'  linear slope: %f db/day \n',coef_exfit(3));    fprintf(fidlog,'  mean offset: %f db \n',coef_exfit(4));        pfit = pr_exfit;elseif fit_select == 2    fprintf(1,'Linear pressure fit stored with data \n');    fprintf(1,'  linear slope: %f db/day \n',coef_linfit(1));    fprintf(1,'  mean offset: %f db \n',coef_linfit(2));        fprintf(fidlog,'Linear pressure fit stored with data \n');    fprintf(fidlog,'  linear slope: %f db/day \n',coef_linfit(1));    fprintf(fidlog,'  mean offset: %f db \n',coef_linfit(2));        pfit = pr_linfit;else    pfit = pr_int;endsubplot(3,1,2);plot(jd_grid(iip)-jd0,auto_filt(pr_int(iip),sampling_rate,1/2,'low',4)-pfit)title('Empirical drift estimate subtracted')ylabel('Pressure [dbar]')grid onxlim([jd1 jd2])% timeaxis(plot_interval(1,1:3));datetick('x',12)subplot(3,1,3);plot(jd_grid(iit)-jd0,auto_filt(t_int(iit),sampling_rate,1/2,'low',4))ylabel('Temperature [deg C]')grid onxlim([jd1 jd2])%  timeaxis(plot_interval(1,1:3));datetick('x',12)orient tallprint(gcf,'-depsc',[outfile '.2.eps']);%% ------------- put pressure onto travel time grid -------------if 1 % this is quite complicated . . .    % ceil/floor to nearest 10 minutes    jdtth_s = ceil(jdtth(1)*24*6)/24/6;    jd_grid_s = ceil(jd_grid(1)*24*6)/24/6;        jdtth_e = floor(jdtth(end)*24*6)/24/6;    jd_grid_e = floor(jd_grid(end)*24*6)/24/6;        % fractional hour remainder for jd_grid    hrem = rem( round(rem(jd_grid,1)*24*6)/6,1);    if jdtth_s >= jd_grid_s        iip_s = min(find( round(jd_grid*24*6)/24/6 >= jdtth_s -1/86400 & ...            hrem==0 ));        iitt_s =1;    elseif jdtth_s < jd_grid_s        iip_s = min(find(hrem==0)); % first value on the hour        iitt_s = find( round(jd_grid(iip_s)*24*6) == round(jdtth*24*6) );    end        if jdtth_e >= jd_grid_e        iip_e = max(find(hrem==0));        jd_grid_e = jd_grid(iip_e);        iitt_e = find( round(jd_grid(iip_e)*24*6) == round(jdtth*24*6) );    elseif jdtth_e < jd_grid_e        % last value on the hour less than jdtth_e        iip_e = max(find( hrem==0 & jd_grid <= jdtth_e+1/86400 ));        iitt_e = length(jdtth);        %iitt_e = find( round(jd_grid(iip_e)*24*6) == round(jdtth*24*6) );    end    elseif 0 % try something simpler - round to the nearest hour        teps = 1e-8; % to make sure exact rounding doesn't get in the way    jdtth_s = ceil((jdtth(1)-teps)*24)/24;    jd_grid_s = ceil((jd_grid(1)-teps)*24)/24;    jd_s = max(jdtth_s,jd_grid_s);        jdtth_e = floor((jdtth(end)+teps)*24)/24;    jd_grid_e = floor((jd_grid(end)+teps)*24)/24;    jd_e = min(jdtth_e,jd_grid_e);        [gash, iip_s] = min(abs(jd_grid - jd_s));    [gash, iitt_s] = min(abs(jdtth - jd_s));        [gash, iip_e] = min(abs(jd_grid - jd_e));    [gash, iitt_e] = min(abs(jdtth - jd_e));    endif rem(iip_e - iip_s,6)~=0    disp('iip_s and iip_e are not multiples of 6 apart - something''s wrong')    keyboardendiip = [iip_s:6:iip_e];iitt = [iitt_s:1:iitt_e];if length(iip) ~= length(iitt)    disp('iip and iit are not the same lengths - something''s wrong')    keyboardendjdtth_h = jdtth(iitt);    jdtth_h = jdtth_h(:);jd_grid_h = jd_grid(iip);  jd_grid_h = jd_grid_h(:);isequal( round(jdtth_h*24*6), round(jd_grid_h*24*6) )if ~isequal( round(jdtth_h*24*6), round(jd_grid_h*24*6) )    disp('The aligned time-grids are not the same (within 10 minutes)')    disp('W A R N I N G: rodb output has timing errors')    fprintf(fidlog,['The aligned time-grids are not the same '...        '(within 10 minutes) \n'])    fprintf(fidlog,'W A R N I N G: rodb output has timing errors \n')endttm_h = ttm(iitt);pr_int_h = pr_int(iip);pfit_h = pfit(iip);t_int_h = t_int(iip);% ------------- save data in rodb format -------------outvars = ['Latitude:Longitude:Columns:Start_Date:Start_Time:SerialNumber:'...    'Mooring:WaterDepth:Instrdepth:End_Date:End_Time'];% in outfile, save the median of 4-ping hourly medians and the subsampled% pressure data, measurements every hour on the hourcols      = 'YY:MM:DD:HH:TT:P:PFIT:T';fort      = '%4.4d  %2.2d  %2.2d  %7.5f   %8.6f  %8.4f  %8.4f  %7.4f';time       = gregorian(jdtth_h);data      = [time(:,1:3) hms2h(time(:,4:6)) ttm_h(:) ...    pr_int_h(:) pfit_h(:) t_int_h(:)];disp(['writing data to ' outfile])rodbsave(outfile,outvars,fort,lat,lon,cols,sdate,stime(1:2),...    serialnumber,mooring,wd,z,edate,etime(1:2),data);% in pressure outfile, save the full time resolution pressure data,% measurements every 10 minutescolsp     = 'YY:MM:DD:HH:P:PFIT:T';fortp     = '%4.4d  %2.2d  %2.2d  %7.5f   %8.4f  %8.4f  %7.4f';timep     = gregorian(jd_grid);datap     = [timep(:,1:3) hms2h(timep(:,4:6)) pr_int(:) pfit(:) t_int(:)];disp(['writing pressure data to ' outfilep])rodbsave(outfilep,outvars,fortp,lat,lon,colsp,sdate,stime(1:2),...    serialnumber,mooring,wd,z,edate,etime(1:2),datap);fclose(fidlog);