% function adcp_raw2use_01(moor,'procpath',procpath,'outpath',outpath)%% basic preprocessing for RDI ADCP data% % required inputs: moor - mooring name e.g 'eb3_1_200406'%% optional inputs: procpath - path to proc directory if not using standard%                             paths%                  outpath - path to output processed files to - otherwise%                            outputs to directory function run from%                  plot_interval - matrix of start and end dates for plot%                                  e.g. [2004 02 01 00; 2005 06 01 00]%                                  dates are:- yyyy mm dd hh%% features%      1. eliminate launching and recovery period%      2. save data to rodb file%      3. create data overview sheet%% uses timeaxis.m, auto_filt.m, julian.m, rodbload.m, rodbsave.m%% 10/12/09 - DR modified from dvs_raw2use_01% 19/10/20 - LH fix bug on instrument depth (target depth) which was erased to bin depth indep%function adcp_raw2use_01(moor,varargin)  global MOORPROC_Gbasedir = MOORPROC_G.moordatadir;cruise= MOORPROC_G.cruise;if nargin==0    help adcp_raw2use_01    returnendif nargin==1    pd = moor_inoutpaths('adcp',moor);else    pd = varargin{1};enda = find(strcmp('plot_interval', varargin));if a>0 && ~isempty(varargin{a+1})    plot_interval=reshape(varargin{a+1},4,2)';else    plot_interval=[];endoperator = MOORPROC_G.operator;% ----- read infofile / open logfile  ------------------------------------infovar = 'instrument:serialnumber:z:Start_Time:Start_Date:End_Time:End_Date:Latitude:Longitude:WaterDepth:Mooring';[id,sn,z,s_t,s_d,e_t,e_d,lat,lon,wd,mr]  =  rodbload(pd.infofile,infovar);vec=find((id>=319) & (id <=328)); % Possible ADCP codes - taken from IMP moorings packagesn=sn(vec);z = z(vec);fid_stat= fopen(pd.stage2log,'w');fprintf(fid_stat,['Processing steps taken by ' mfilename ':\n']);fprintf(fid_stat,'  1. eliminate lauching and recovery period\n');fprintf(fid_stat,'  2. save data to rodb file\n');fprintf(fid_stat,'\n Operated by:%s on %s\n',operator,datestr(clock)); fprintf(fid_stat,['        ADCPs in Mooring ',moor,'\n\n\n']);% Determine plot_interval if not input to functionif isempty(plot_interval)    plot_interval = [s_d(1) s_d(2)-1 s_d(3) 0; e_d(1) e_d(2)+1 e_d(3) 0];    if plot_interval(1,2)==0        plot_interval(1,2)=12; plot_interval(1,1)=plot_interval(1,1)-1;    end    if plot_interval(2,2)==13        plot_interval(2,2)=1; plot_interval(2,1)=plot_interval(2,1)+1;    endend%-----------------------------------------% --- preprocessing loop -------------------% ----------------------------------------jd_s = julian([s_d(:)' hms2h([s_t(:)' 0])]); %startjd_e = julian([e_d(:)' hms2h([e_t(:)' 0])]); %end%all_z=[combo_z individual_z];%all_sn=[combo_sn individual_sn];zADCP = z ;for proc = 1 : length(vec) % loop for multiple instruments on moooring        % first determine how many bin files are to be processed    % trying to do automatically    num_bins=dir(fullfile(pd.stage1path,...        [sprintf(pd.stage2inform,sn(proc)),'*.raw']));    num_bins=length(num_bins);    clear press_sensor    disp(['ADCP Serial number: ' num2str(sn(proc))])          indep  = zADCP(proc);           for j=1:num_bins % loop for total number of bins                columns = ['YY:MM:DD:HH:Z:T:U:V:W:HDG:PIT:ROL:CS:CD:',...            'BEAM1SS:BEAM2SS:BEAM3SS:BEAM4SS:BEAM1COR:BEAM2COR:',...            'BEAM3COR:BEAM4COR:EV:BEAM1PGP:BEAM2PGP:BEAM3PGP:BEAM4PGP'];                      infile = fullfile(pd.stage1path,sprintf(pd.stage1form,sn(proc),j));                if exist(infile,'file')==0            disp(['infile: ' infile ' does not exist.'])        elseif exist(infile,'file')   > 0                         outfile = fullfile(pd.stage2path,sprintf(pd.stage2form,sn(proc),j));            fprintf(fid_stat,'Serialnumber %d \n',sn(proc));            fprintf(fid_stat,'Bin %d \n',j);            fprintf(fid_stat,'Infile %s \n',infile);            fprintf(fid_stat,'Outfile %s \n',outfile);                                 [YY,MM,DD,HH,z,t,u,v,w,heading,pitch,roll,spd,...                direction,Amp1,Amp2,Amp3,Amp4,...                Beam1Cor,Beam2Cor,Beam3Cor,Beam4Cor,err,PG1,PG2,PG3,PG4] = ...                rodbload(infile,[columns]);                                 %------------------------------------------             %----- cut off launching and recovery period            %------------------------------------------            disp('cut off launching and recovery period')            jd  = julian(YY,MM,DD,HH);            ii  = find(jd <= jd_e & jd >= jd_s );            YY=YY(ii);MM=MM(ii);DD=DD(ii);HH=HH(ii);            u=u(ii);v=v(ii);w=w(ii);            heading=heading(ii);pitch=pitch(ii);roll=roll(ii);            t=t(ii);            Amp1=Amp1(ii);Amp2=Amp2(ii);Amp3=Amp3(ii);Amp4=Amp4(ii);            Beam1Cor=Beam1Cor(ii);Beam2Cor=Beam2Cor(ii);Beam3Cor=Beam3Cor(ii);Beam4Cor=Beam4Cor(ii);                        spd=spd(ii); direction=direction(ii);            err=err(ii);            PG1=PG1(ii);PG2=PG2(ii);PG3=PG3(ii);PG4=PG4(ii);            z=z(ii);                        jd  = jd(ii);             cycles     = length(ii);            Start_Date = [YY(1) MM(1) DD(1)];            Start_Time = HH(1);            End_Date = [YY(cycles) MM(cycles) DD(cycles)];            End_Time = HH(cycles);                 %------------------------------------------            %---- fill time gaps  with dummy            %------------------------------------------            disp(' fill time gaps  with dummy')            djd = diff(jd);           % time step              sr  = median(djd);        % sampling interval            ii  = find(djd > 1.5*sr);  % find gaps            gap = round(djd(ii)/sr)-1;            addt= [];             %-----------------------------------------------------            %  write output to logfile ---------------------------            %-----------------------------------------------------            fprintf(fid_stat,'Operation interval: %s  to  %s\n', ...                  datestr(gregorian(jd(1))),datestr(gregorian(jd(end)) ));            fprintf(fid_stat,'\n');            %-----------------------------------              %--- write data to rodb format -----            %-----------------------------------            disp(['writing data to ',outfile])             fort =['%4.4d %2.2d %2.2d  %6.4f  %4.2f  %4.2f %4.1f %4.1f %4.1f  %4.2f '...                    '%4.2f %4.2f  %4.1f  %4.1f  %3.0f %3.0f %3.0f %3.0f   '...                    '%3.0f %3.0f %3.0f %3.0f  %4.1f  %3.0f %3.0f %3.0f %3.0f'];            data = [YY MM DD HH z t u v w heading pitch roll spd direction ...                    Amp1 Amp2 Amp3 Amp4 Beam1Cor Beam2Cor Beam3Cor Beam4Cor ...                    err PG1 PG2 PG3 PG4];             rodbsave(outfile,...              'Latitude:Longitude:Columns:Start_Date:Start_Time:SerialNumber:Mooring:WaterDepth:Instrdepth:End_Date:End_Time',...               fort,...              lat,lon,columns,Start_Date,Start_Time,sn(proc),mr,wd,indep,End_Date,End_Time,...              data);            %%%%%%%%%% Graphics %%%%%%%%%%%%%%%%            jd0 = julian(-1,1,1,24);            jd1 = julian(plot_interval(1,:))-jd0;            jd2 = julian(plot_interval(2,:))-jd0;             sampling_rate = 1/median(diff(jd));                        STR = ['Zonal Velocity [cm/s] ';                   'Merid. Velocity [cm/s]';                   'Vert. Velocity [cm/s] ';                   'Heading [degrees]     ';                   'Depth [m]             ';                   'Temp. at ADCP [deg C] '];             STR2 = {'Heading [deg]';                'angle [deg]';                'sig. str. [counts]';                'percent good'};            VAR1 = {'u';'v';'w';'heading';'z';'t'};             VAR2= {'heading';'pitch';'roll';'Amp1';'Amp2';'Amp3';'Amp4'};            plot_vars=6;            panels2=3;                        panels=plot_vars;            fig1=figure(1);clf            for sub = 1 : plot_vars              eval(['var1 = ',VAR1{sub},';'])              var2=[];var3=[];var4=[];              ok = plot_timeseries(jd,var1,var2,var3,var4,sampling_rate,STR(sub,:),sub,[jd1 jd2],'n',panels);            end            subplot(plot_vars,1,1)            title(['ADCP s/n: ',num2str(sn(proc)), ...                 '; Target Depth: ',num2str(indep), ...                 '; Bin ',num2str(j)]);            orient tall            print(fig1,'-dpng', '-r300',[outfile '.png'])            fig2=figure(2);clf            for sub = 1 : plot_vars              eval(['var1 = ',VAR1{sub},';'])              ok = plot_timeseries(jd,var1,var2,var3,var4,sampling_rate,STR(sub,:),sub,[jd1 jd2],'y',panels);            end            subplot(plot_vars,1,1)            title(['ADCP s/n: ',num2str(sn(proc)), ...                   '; Target Depth: ',num2str(indep), ...                 '; Bin ',num2str(j)]);            orient tall            print(fig2,'-dpng', '-r300',[outfile '.filtered.png'])                        % plot of diagnostics info        fig3 = figure(3);clf        subplot(3,1,1)        eval(['var1 = ',VAR2{1},';'])        var2=[];        var3=[];        ok = plot_timeseries(jd,var1,var2,var3,var4,sampling_rate,STR2{1},1,[jd1 jd2],'n',panels2);        legend({'hdg'})        subplot(3,1,2)        eval(['var1 = ',VAR2{2},';'])        eval(['var2 = ',VAR2{3},';'])        var3=[];        ok = plot_timeseries(jd,var1,var2,var3,var4,sampling_rate,STR2{2},2,[jd1 jd2],'n',panels2);        legend({'pit','rol'})        subplot(3,1,3)        eval(['var1 = ',VAR2{4},';'])        eval(['var2 = ',VAR2{5},';'])        eval(['var3 = ',VAR2{6},';'])        eval(['var4 = ',VAR2{7},';'])        ok = plot_timeseries(jd,var1,var2,var3,var4,sampling_rate,STR2{3},3,[jd1 jd2],'n',panels2);                if ~isempty(var4(~isnan(var4)))            legend({'beam1','beam2','beam3','beam4'})        else            legend({'beam1','beam2','beam3'})        end        subplot(panels2,1,1)            title(['ADCP s/n: ',num2str(sn(proc)), ...                   '; Target Depth: ',num2str(indep), ...                 '; Bin ',num2str(j)]);        orient tall        print(fig3,'-dpng', '-r300',[outfile '_diagnostics.png'])        end % if exist(infile)==0    end % loop for different bin depthsend  % for proc=1:length(combo_sn)+length(individual_sn) loopend % function  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  function ok = plot_timeseries(jd,var1,var2,var3,var4,sr,str,sub,jdlim,filt,panels)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% plot time series  jd0 = julian(-1,1,1,24);  i1    = find(~isnan(var1) & var1~=0);   if strcmp(filt,'y')    var1  = auto_filt(var1(i1),sr,1/2,'low',4);  else    var1  = var1(i1);  end   if ~isempty(var2)    i2    = find(~isnan(var2) & var2~=0);    if strcmp(filt,'y')      var2  = auto_filt(var2(i2),sr,1/2,'low',4);    else      var2  = var2(i2);    end  end    if ~isempty(var3)    i3    = find(~isnan(var3) & var3~=0);    if strcmp(filt,'y')        var3  = auto_filt(var3(i3),sr,1/2,'low',4);    else        var3  = var3(i3);    end end    if ~isempty(var4)    i4    = find(~isnan(var4) & var4~=0);    if strcmp(filt,'y')        var4  = auto_filt(var4(i4),sr,1/2,'low',4);    else        var4  = var4(i4);    end end  subplot(panels,1,sub);    if ~isempty(var1(~isnan(var1)))           plot(jd(i1)-jd0,var1)  end  hold on  if ~isempty(var2(~isnan(var2)))    plot(jd(i2)-jd0,var2,'r')  end    if ~isempty(var3(~isnan(var3)))    plot(jd(i3)-jd0,var3,'g')  end    if ~isempty(var4(~isnan(var4)))    plot(jd(i4)-jd0,var4,'--k','LineWidth', 0.2)  end   ylabel(str)  grid on  xlim([jdlim])  datetick('x',12,'keeplimits')        ok=1;  end